'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

function _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }

var React = require('react');
var mobx = require('mobx');
var rest = require('@cuba-platform/rest');
var mobxReact = require('mobx-react');
var moment = _interopDefault(require('moment'));

var __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
class Security {
    constructor(cubaREST) {
        this.cubaREST = cubaREST;
        this.attrPermissionCache = new mobx.ObservableMap();
        this.restSupportEffectivePerms = true;
        this.permissionsRequestCount = 0;
        this.getAttributePermission = (entityName, attributeName) => {
            if (!this.isDataLoaded)
                return 'DENY';
            // do not deny anything for rest version prev 7.2
            if (!this.restSupportEffectivePerms)
                return 'MODIFY';
            const attrFqn = `${entityName}:${attributeName}`;
            let perm = this.attrPermissionCache.get(attrFqn);
            if (perm != null)
                return perm;
            perm = rest.getAttributePermission(entityName, attributeName, this.effectivePermissions);
            this.attrPermissionCache.set(attrFqn, perm);
            return perm;
        };
        this.canUploadAndLinkFile = () => {
            if (!this.isDataLoaded) {
                return false;
            }
            if (!this.restSupportEffectivePerms) {
                return true;
            }
            return rest.isOperationAllowed('sys$FileDescriptor', 'create', this.effectivePermissions)
                && rest.isSpecificPermissionGranted('cuba.restApi.fileUpload.enabled', this.effectivePermissions);
        };
    }
    get isDataLoaded() {
        return this.effectivePermissions != null || !this.restSupportEffectivePerms;
    }
    ;
    loadPermissions() {
        const requestId = ++this.permissionsRequestCount;
        this.effectivePermissions = undefined;
        this.attrPermissionCache.clear();
        return this.cubaREST.getEffectivePermissions()
            .then(mobx.action((effectivePermsInfo) => {
            if (requestId === this.permissionsRequestCount) {
                this.effectivePermissions = effectivePermsInfo;
            }
        }))
            .catch(reason => {
            // support rest api version < 7.2
            if (reason === rest.CubaApp.NOT_SUPPORTED_BY_API_VERSION) {
                this.restSupportEffectivePerms = false;
            }
            else {
                throw reason;
            }
        });
    }
}
__decorate([
    mobx.observable
], Security.prototype, "attrPermissionCache", void 0);
__decorate([
    mobx.observable
], Security.prototype, "effectivePermissions", void 0);
__decorate([
    mobx.observable
], Security.prototype, "restSupportEffectivePerms", void 0);
__decorate([
    mobx.computed
], Security.prototype, "isDataLoaded", null);
__decorate([
    mobx.action
], Security.prototype, "loadPermissions", null);

var __decorate$1 = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
class MainStore {
    constructor(cubaREST) {
        this.cubaREST = cubaREST;
        /**
         * Whether the `MainStore` instance is initialized.
         */
        this.initialized = false;
        /**
         * Whether the user authenticated.
         */
        this.authenticated = false;
        /**
         * Whether the user is anonymous.
         */
        this.usingAnonymously = false;
        this.metadataRequestCount = 0;
        this.messagesRequestCount = 0;
        this.enumsRequestCount = 0;
        /**
         * Changes the active locale for this frontend client application.
         *
         * @param locale - locale to be set as active.
         */
        this.setLocale = (locale) => {
            this.cubaREST.locale = locale;
        };
        this.handleLocaleChange = (locale) => {
            this.locale = locale;
            if (this.initialized && (this.authenticated || this.usingAnonymously)) {
                this.loadEnums();
                this.loadMessages();
            }
            if (this.initialized && this.authenticated) {
                this.setSessionLocale();
            }
        };
        this.setSessionLocale = () => {
            this.cubaREST.setSessionLocale().catch((reason) => {
                if (reason === rest.CubaApp.NOT_SUPPORTED_BY_API_VERSION) {
                    console.warn('Relogin is required in order for bean validation messages to use correct locale. ' +
                        'Upgrade to REST API 7.2.0 or higher to be able to change locale without relogin.');
                }
                else {
                    throw new Error('Failed to set session locale');
                }
            });
        };
        this.cubaREST.onLocaleChange(this.handleLocaleChange);
        this.security = new Security(this.cubaREST);
        mobx.autorun(() => {
            if (this.initialized && (this.authenticated || this.usingAnonymously)) {
                this.security.loadPermissions();
                this.loadEnums();
                this.loadMetadata();
                this.loadMessages();
            }
        });
    }
    /**
     * `true` means that `MainStore` is in a state when entity data can be displayed (i.e. entity metadata,
     * localized entity messages, localized enums and permissions information has been loaded).
     */
    isEntityDataLoaded() {
        return this.messages != null
            && this.metadata != null
            && this.enums != null
            && this.security.isDataLoaded;
    }
    /**
     * Retrieves localized enums using REST API.
     */
    loadEnums() {
        const requestId = ++this.enumsRequestCount;
        this.cubaREST.loadEnums()
            .then(mobx.action((enums) => {
            if (requestId === this.enumsRequestCount) {
                this.enums = mobx.observable(enums);
            }
        }));
    }
    /**
     * Retrieves entity metadata using REST API.
     */
    loadMetadata() {
        const requestId = ++this.metadataRequestCount;
        this.cubaREST.loadMetadata()
            .then(mobx.action((metadata) => {
            if (requestId === this.metadataRequestCount) {
                this.metadata = mobx.observable(metadata);
            }
        }));
    }
    /**
     * Retrieves localized entity messages using REST API.
     */
    loadMessages() {
        const requestId = ++this.messagesRequestCount;
        this.cubaREST.loadEntitiesMessages()
            .then(mobx.action((res) => {
            if (requestId === this.messagesRequestCount) {
                this.messages = res;
            }
        }));
    }
    get loginRequired() {
        return !this.authenticated && !this.usingAnonymously;
    }
    login(login, password) {
        return this.cubaREST.login(login, password).then(mobx.action(() => {
            this.userName = login;
            this.authenticated = true;
        }));
    }
    logout() {
        if (this.usingAnonymously) {
            this.usingAnonymously = false;
            return Promise.resolve();
        }
        if (this.cubaREST.restApiToken != null) {
            return this.cubaREST.logout()
                .then(mobx.action(() => {
                this.authenticated = false;
            }));
        }
        return Promise.resolve();
    }
    /**
     * Initializes this `MainStore` instance.
     *
     * @returns a promise that resolves when initialization is complete.
     */
    initialize() {
        this.locale = this.cubaREST.locale;
        return this.cubaREST.getUserInfo()
            .then(mobx.action((userInfo) => {
            if (this.cubaREST.restApiToken == null) {
                this.usingAnonymously = true;
            }
            else {
                this.authenticated = true;
            }
            this.userName = userInfo.name;
            this.initialized = true;
        }))
            .catch(mobx.action(() => {
            this.initialized = true;
        }));
    }
}
MainStore.NAME = 'mainStore';
__decorate$1([
    mobx.observable
], MainStore.prototype, "initialized", void 0);
__decorate$1([
    mobx.observable
], MainStore.prototype, "authenticated", void 0);
__decorate$1([
    mobx.observable
], MainStore.prototype, "usingAnonymously", void 0);
__decorate$1([
    mobx.observable
], MainStore.prototype, "userName", void 0);
__decorate$1([
    mobx.observable
], MainStore.prototype, "locale", void 0);
__decorate$1([
    mobx.observable
], MainStore.prototype, "metadata", void 0);
__decorate$1([
    mobx.observable
], MainStore.prototype, "messages", void 0);
__decorate$1([
    mobx.observable
], MainStore.prototype, "enums", void 0);
__decorate$1([
    mobx.action
], MainStore.prototype, "loadEnums", null);
__decorate$1([
    mobx.action
], MainStore.prototype, "loadMetadata", null);
__decorate$1([
    mobx.action
], MainStore.prototype, "loadMessages", null);
__decorate$1([
    mobx.computed
], MainStore.prototype, "loginRequired", null);
__decorate$1([
    mobx.action
], MainStore.prototype, "login", null);
__decorate$1([
    mobx.action
], MainStore.prototype, "logout", null);
__decorate$1([
    mobx.action
], MainStore.prototype, "handleLocaleChange", void 0);
function injectMainStore(target) {
    return mobxReact.inject(MainStore.NAME)(target);
}

let cubaAppContext;
let cubaAppConfig;
let globalCubaREST;
let mainStore;
function getCubaREST() {
    return globalCubaREST;
}
function getMainStore() {
    return mainStore;
}
function getCubaAppConfig() {
    return cubaAppConfig;
}
const CubaAppProvider = ({ cubaREST, children, retrieveRestApiToken = () => Promise.resolve(undefined), config }) => {
    const CubaAppContext = getContext();
    return (React.createElement(CubaAppContext.Consumer, null, (context = {}) => {
        if (cubaREST && context.cubaREST !== cubaREST) {
            cubaAppConfig = config;
            globalCubaREST = cubaREST;
            mainStore = new MainStore(cubaREST);
            retrieveRestApiToken().then((restApiToken) => {
                if (restApiToken != null) {
                    cubaREST.restApiToken = restApiToken;
                }
                mainStore.initialize();
            });
            context = Object.assign({}, context, { cubaREST });
        }
        if (!context.cubaREST) {
            throw new Error("cubaREST instance is not passed");
        }
        return (React.createElement(CubaAppContext.Provider, { value: context },
            React.createElement(mobxReact.Provider, { mainStore: mainStore }, children)));
    }));
};
function getContext() {
    if (!cubaAppContext) {
        cubaAppContext = React.createContext({});
    }
    return cubaAppContext;
}

const menuItems = [];
function getMenuItems() {
    return menuItems;
}

var __decorate$2 = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
class DataContext {
    constructor(containers) {
        this.save = () => {
            for (const containerName in this.containers) {
                if (!this.containers.hasOwnProperty(containerName)) {
                    continue;
                }
                const container = this.containers[containerName];
                container.changedItems.forEach((entity) => {
                    getCubaREST().commitEntity(container.entityName, entity);
                });
            }
        };
        this.containers = containers;
    }
    get hasChanges() {
        if (!this.containers || Object.getOwnPropertyNames(this.containers).length < 1) {
            return false;
        }
        for (const containerName in this.containers) {
            if (!this.containers.hasOwnProperty(containerName)) {
                continue;
            }
            if (this.containers[containerName].changedItems != null && this.containers[containerName].changedItems.length > 0) {
                return true;
            }
        }
        return false;
    }
}
__decorate$2([
    mobx.observable
], DataContext.prototype, "containers", void 0);
__decorate$2([
    mobx.action
], DataContext.prototype, "save", void 0);
__decorate$2([
    mobx.computed
], DataContext.prototype, "hasChanges", null);
function data(containers) {
    return new DataContext(containers);
}

// TODO Implement client-side filtering
// export function filterEntityInstances<T>(items: Array<SerializedEntity<T>>, _filter: EntityFilter | undefined): Array<SerializedEntity<T>> {
//   return items;
// }
/**
 * Performs client-side sorting of entities, mimicking the way sorting is performed by REST API
 *
 * @param items - entity instances array
 * @param sort - REST API parameter representing sort field and order
 */
function sortEntityInstances(items, sort) {
    if (sort == null) {
        return items;
    }
    let fieldName = sort;
    let isAscending = true;
    if (sort.startsWith('+')) {
        fieldName = sort.slice(1);
    }
    else if (sort.startsWith('-')) {
        fieldName = sort.slice(1);
        isAscending = false;
    }
    const sortOrderModifier = isAscending ? 1 : -1;
    return items.sort((a, b) => {
        var _a, _b;
        let valA = a[fieldName];
        let valB = b[fieldName];
        if (valA === valB) {
            return 0;
        }
        // null and undefined go to bottom in ascending sort (i.e. are "greater" than any values)
        if (valA == null && valB != null) {
            // valA is null or undefined, but not valB -> valA is "greater" than valB
            return 1 * sortOrderModifier;
        }
        if (valB == null) {
            if (valA != null) {
                // valB is null or undefined, but not valA -> valB is "greater" than valA
                return -1 * sortOrderModifier;
            }
            // One is null and the other is undefined
            return 0;
        }
        if (typeof valA !== typeof valB) {
            // tslint:disable-next-line:no-console
            console.warn('Unexpected value encountered when performing client-side sorting of entity instances.' +
                ' The types of the values being compared differ and neither value is null or undefined.' +
                ' This might indicate a bug in the application. Sort order is not guaranteed to be correct.');
            return 0;
        }
        switch (typeof valA) {
            case 'number':
                if (!isFinite(valA) || !isFinite(valB)) {
                    // tslint:disable-next-line:no-console
                    console.warn('Unexpected value encountered when performing client-side sorting of entity instances.' +
                        ' A numeric field contains a value that is NaN, positive or negative Infinity.' +
                        ' This might indicate a bug in the application.');
                    // Still attempt to sort the values
                    // NaN is treated the same as null or undefined
                    if (isNaN(valA) && !isNaN(valB)) {
                        // valA is NaN, but not valB -> valA is "greater" than valB
                        return 1 * sortOrderModifier;
                    }
                    if (isNaN(valB)) {
                        if (!isNaN(valA)) {
                            // valB is NaN, but not valA -> valB is "greater" than valA
                            return -1 * sortOrderModifier;
                        }
                        // Both are NaN
                        return 0;
                    }
                    // defaultCompare but one or both values are negative or positive Infinity
                    return defaultCompare(valA, valB, sortOrderModifier);
                }
                return defaultCompare(valA, valB, sortOrderModifier);
            case 'object':
                const nameA = valA._instanceName != null ? valA._instanceName : '';
                const nameB = valB._instanceName != null ? valB._instanceName : '';
                return defaultCompare(nameA, nameB, sortOrderModifier);
            case 'string':
                // Imitate REST API behavior for consistency
                const nonAlphaNumericRegex = /[^0-9a-zA-Z]/g;
                const nonAlphaNumericCharsA = ((_a = valA.match(nonAlphaNumericRegex)) === null || _a === void 0 ? void 0 : _a.join('')) || '';
                const nonAlphaNumericCharsB = ((_b = valB.match(nonAlphaNumericRegex)) === null || _b === void 0 ? void 0 : _b.join('')) || '';
                valA = valA.replace(nonAlphaNumericRegex, '').toLowerCase();
                valB = valB.replace(nonAlphaNumericRegex, '').toLowerCase();
                const result = defaultCompare(valA, valB, sortOrderModifier);
                if (result !== 0) {
                    return result;
                }
                return defaultCompare(nonAlphaNumericCharsA, nonAlphaNumericCharsB, sortOrderModifier);
            case 'boolean':
                return defaultCompare(valA, valB, sortOrderModifier);
        }
        // tslint:disable-next-line:no-console
        console.warn('Unexpected value encountered when performing client-side sorting of entity instances.' +
            ` Value ${valA} of type ${typeof valA} is being compared to value ${valB} of type ${typeof valB}.` +
            ' Sort order is not guaranteed to be correct.');
        return 0;
    });
}
function defaultCompare(valA, valB, sortOrderModifier = 1) {
    if (valA < valB) {
        return -1 * sortOrderModifier;
    }
    else if (valA > valB) {
        return 1 * sortOrderModifier;
    }
    else {
        return 0;
    }
}

var __decorate$3 = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
class DataCollectionStoreImpl {
    constructor(entityName, trackChanges = false, viewName = rest.PredefinedView.MINIMAL, sort) {
        this.entityName = entityName;
        this.trackChanges = trackChanges;
        this.items = [];
        this.status = "CLEAN";
        this.allItems = []; // Client mode only
        this.changedItems = mobx.observable([]);
        this.load = () => {
            this.changedItems.clear();
            this.status = "LOADING";
            let loadingPromise;
            if (this.filter) {
                loadingPromise = this.handleLoadingWithCount(getCubaREST().searchEntitiesWithCount(this.entityName, this.filter, this.entitiesLoadOptions));
            }
            else if (this.skipCount === true) {
                loadingPromise = this.handleLoadingNoCount(getCubaREST().loadEntities(this.entityName, this.entitiesLoadOptions));
            }
            else {
                loadingPromise = this.handleLoadingWithCount(getCubaREST().loadEntitiesWithCount(this.entityName, this.entitiesLoadOptions));
            }
            loadingPromise.catch(() => mobx.runInAction(() => {
                this.status = 'ERROR';
                this.lastError = 'LOAD_ERROR';
            }));
            return loadingPromise;
        };
        this.clear = () => {
            this.items = [];
            this.changedItems.clear();
            this.status = 'CLEAN';
        };
        this.delete = (e) => {
            if (e == null || e.id == null) {
                throw new Error('Unable to delete entity without ID');
            }
            this.status = 'LOADING';
            return getCubaREST().deleteEntity(this.entityName, e.id)
                .then(mobx.action(() => {
                this.load();
                return true;
            }))
                .catch(mobx.action(() => {
                this.status = "ERROR";
                this.lastError = "COMMIT_ERROR";
                return true;
            }));
        };
        this.view = viewName;
        if (sort) {
            this.sort = sort;
        }
        if (this.trackChanges) {
            mobx.reaction(() => [this.items, this.items.length], () => {
                this.changedItems.push(this.items);
            });
        }
        mobx.reaction(() => this.status, status => this.lastError = status !== "ERROR" ? undefined : this.lastError);
    }
    get readOnlyItems() {
        return mobx.toJS(this.items);
    }
    get properties() {
        return [];
    }
    get entitiesLoadOptions() {
        const loadOptions = {
            view: this.view,
        };
        if (this.sort) {
            loadOptions.sort = this.sort;
        }
        if (this.limit !== null && this.limit !== undefined) {
            loadOptions.limit = this.limit;
        }
        if (this.offset !== null && this.offset !== undefined) {
            loadOptions.offset = this.offset;
        }
        return loadOptions;
    }
    handleLoadingWithCount(promise) {
        return promise
            .then((resp) => {
            mobx.runInAction(() => {
                this.items = fromRestModel(resp.result, this.stringIdName);
                this.count = resp.count;
                this.status = 'DONE';
            });
        });
    }
    handleLoadingNoCount(promise) {
        return promise
            .then((resp) => {
            mobx.runInAction(() => {
                this.items = fromRestModel(resp, this.stringIdName);
                this.count = undefined;
                this.status = 'DONE';
            });
        });
    }
}
__decorate$3([
    mobx.observable
], DataCollectionStoreImpl.prototype, "items", void 0);
__decorate$3([
    mobx.observable
], DataCollectionStoreImpl.prototype, "status", void 0);
__decorate$3([
    mobx.observable
], DataCollectionStoreImpl.prototype, "lastError", void 0);
__decorate$3([
    mobx.observable
], DataCollectionStoreImpl.prototype, "view", void 0);
__decorate$3([
    mobx.observable
], DataCollectionStoreImpl.prototype, "sort", void 0);
__decorate$3([
    mobx.observable
], DataCollectionStoreImpl.prototype, "filter", void 0);
__decorate$3([
    mobx.observable
], DataCollectionStoreImpl.prototype, "limit", void 0);
__decorate$3([
    mobx.observable
], DataCollectionStoreImpl.prototype, "offset", void 0);
__decorate$3([
    mobx.observable
], DataCollectionStoreImpl.prototype, "count", void 0);
__decorate$3([
    mobx.observable
], DataCollectionStoreImpl.prototype, "skipCount", void 0);
__decorate$3([
    mobx.observable
], DataCollectionStoreImpl.prototype, "stringIdName", void 0);
__decorate$3([
    mobx.action
], DataCollectionStoreImpl.prototype, "load", void 0);
__decorate$3([
    mobx.action
], DataCollectionStoreImpl.prototype, "clear", void 0);
__decorate$3([
    mobx.action
], DataCollectionStoreImpl.prototype, "delete", void 0);
__decorate$3([
    mobx.computed
], DataCollectionStoreImpl.prototype, "readOnlyItems", null);
__decorate$3([
    mobx.computed // todo will be reworked as part of https://github.com/cuba-platform/frontend/issues/4
], DataCollectionStoreImpl.prototype, "properties", null);
class ClientSideDataCollectionStoreImpl extends DataCollectionStoreImpl {
    constructor(entityName, trackChanges = false, viewName = rest.PredefinedView.MINIMAL, sort) {
        super(entityName, trackChanges, viewName, sort);
        this.entityName = entityName;
        this.trackChanges = trackChanges;
        this.allItems = [];
        this.load = () => {
            this.adjustItems();
            return Promise.resolve();
        };
        this.adjustItems = () => {
            // Currently only sorts the items. Client-side filtering can be implemented here:
            // const filteredItems = filterEntityInstances([...this.allItems], this.filter);
            this.items = sortEntityInstances([...this.allItems], this.sort);
        };
        this.delete = (e) => {
            this.allItems = this.allItems.filter((item) => (item != null && item.id !== e.id));
            this.adjustItems();
            return Promise.resolve();
        };
    }
}
__decorate$3([
    mobx.action
], ClientSideDataCollectionStoreImpl.prototype, "load", void 0);
__decorate$3([
    mobx.action
], ClientSideDataCollectionStoreImpl.prototype, "adjustItems", void 0);
__decorate$3([
    mobx.action
], ClientSideDataCollectionStoreImpl.prototype, "delete", void 0);
const defaultOpts = {
    loadImmediately: true
};
function fromRestModel(items, stringIdName) {
    if (stringIdName == null || stringIdName === 'id') {
        return items;
    }
    else {
        return items.map(i => {
            const item = i;
            if (stringIdName != null) {
                item[stringIdName] = item.id;
            }
            return item;
        });
    }
}
function createStore(entityName, opts) {
    const dataCollection = new DataCollectionStoreImpl(entityName, !!opts.trackChanges);
    setOptionsAndLoad(dataCollection, opts);
    return dataCollection;
}
function createClientSideStore(entityName, opts) {
    const dataCollection = new ClientSideDataCollectionStoreImpl(entityName, !!opts.trackChanges);
    if (opts.allItems != null) {
        dataCollection.allItems = opts.allItems;
    }
    setOptionsAndLoad(dataCollection, opts);
    return dataCollection;
}
function setOptionsAndLoad(dataCollection, opts) {
    if (opts.view != null) {
        dataCollection.view = opts.view;
    }
    if (opts.filter != null) {
        dataCollection.filter = opts.filter;
    }
    if (opts.sort != null) {
        dataCollection.sort = opts.sort;
    }
    if (opts.limit != null) {
        dataCollection.limit = opts.limit;
    }
    if (opts.offset != null) {
        dataCollection.offset = opts.offset;
    }
    if (opts.stringIdName != null) {
        dataCollection.stringIdName = opts.stringIdName;
    }
    if (typeof opts.loadImmediately === 'undefined' || opts.loadImmediately) {
        dataCollection.load();
    }
}
// todo will be reworked as part of https://github.com/cuba-platform/frontend/issues/4
const withDataCollection = (entityName, opts = defaultOpts) => (target) => {
    return mobxReact.inject(() => {
        const dataCollection = createStore(entityName, opts);
        return { dataCollection };
    })(target);
};
/**
 * Initialization function that instantiates a {@link DataCollectionStore} implementation
 * which uses Generic REST API as the source.
 *
 * @typeparam E - entity type.
 *
 * @param entityName - name of the entity to be retrieved.
 * @param opts - {@link DataCollectionStore} configuration.
 */
const collection = (entityName, opts = defaultOpts) => {
    return createStore(entityName, opts);
};
/**
 * Initialization function that instantiates a {@link ClientSideDataCollectionStore} implementation
 *
 * @typeparam E - entity type.
 *
 * @param entityName - name of the entity to be retrieved.
 * @param opts - {@link ClientSideDataCollectionStore} configuration.
 */
const clientSideCollection = (entityName, opts = defaultOpts) => {
    return createClientSideStore(entityName, opts);
};
exports.Collection = class Collection extends React.Component {
    constructor(props) {
        super(props);
        this.store = createStore(this.props.entityName, this.props);
        this.store.load();
    }
    render() {
        return !!this.props.children && this.props.children(this.childrenProps);
    }
    get childrenProps() {
        const { items, status, load, clear } = this.store;
        return Object.assign({ items, status, load, clear });
    }
};
__decorate$3([
    mobx.observable
], exports.Collection.prototype, "store", void 0);
__decorate$3([
    mobx.computed
], exports.Collection.prototype, "childrenProps", null);
exports.Collection = __decorate$3([
    mobxReact.observer
], exports.Collection);

function getPropertyInfo(metadata, entityName, propertyName) {
    const metaClass = metadata.find(mci => mci.entityName === entityName);
    if (metaClass == null) {
        return null;
    }
    const propInfo = metaClass.properties.find(prop => prop.name === propertyName);
    return propInfo || null;
}
/**
 * A non-nullable version of {@link getPropertyInfo}
 *
 * @param propertyName
 * @param entityName
 * @param metadata
 *
 * @throws `Error` when `propertyInfo` is `null`
 */
function getPropertyInfoNN(propertyName, entityName, metadata) {
    const propertyInfo = getPropertyInfo(metadata, entityName, propertyName);
    if (!propertyInfo) {
        throw new Error('Cannot find MetaPropertyInfo for property ' + propertyName);
    }
    return propertyInfo;
}
function getEnumCaption(enumValueName, propertyInfo, enums) {
    const enumInfo = enums.find(enumInfo => enumInfo.name === propertyInfo.type);
    if (!enumInfo) {
        return undefined;
    }
    const enumValue = enumInfo.values
        .find(enumValue => enumValue.name === enumValueName);
    if (!enumValue) {
        return undefined;
    }
    return enumValue.caption;
}
/**
 *
 * @param propertyName
 * @param entityName
 * @param messages
 *
 * @returns localized entity property caption
 */
function getPropertyCaption(propertyName, entityName, messages) {
    return messages[entityName + '.' + propertyName];
}
function isFileProperty(propertyInfo) {
    return (propertyInfo.type === 'sys$FileDescriptor') && isRelationProperty(propertyInfo);
}
function isDateProperty({ type }) {
    return type === 'date';
}
function isLocalDateProperty({ type }) {
    return type === 'localDate';
}
function isTimeProperty({ type }) {
    return type === 'time';
}
function isLocalTimeProperty({ type }) {
    return type === 'localTime';
}
function isOffsetTimeProperty({ type }) {
    return type === 'offsetTime';
}
function isDateTimeProperty({ type }) {
    return type === 'dateTime';
}
function isLocalDateTimeProperty({ type }) {
    return type === 'localDateTime';
}
function isOffsetDateTimeProperty({ type }) {
    return type === 'offsetDateTime';
}
function isAnyDateProperty(propertyInfo) {
    return isDateProperty(propertyInfo)
        || isLocalDateProperty(propertyInfo);
}
function isAnyTimeProperty(propertyInfo) {
    return isTimeProperty(propertyInfo)
        || isLocalTimeProperty(propertyInfo)
        || isOffsetTimeProperty(propertyInfo);
}
function isAnyDateTimeProperty(propertyInfo) {
    return isDateTimeProperty(propertyInfo)
        || isLocalDateTimeProperty(propertyInfo)
        || isOffsetDateTimeProperty(propertyInfo);
}
function isTemporalProperty(propertyInfo) {
    return isAnyDateProperty(propertyInfo)
        || isAnyTimeProperty(propertyInfo)
        || isAnyDateTimeProperty(propertyInfo);
}
function isByteArray({ attributeType, type }) {
    return attributeType === 'DATATYPE' && type === 'byteArray';
}
function isRelationProperty(propertyInfo) {
    return isAssociation(propertyInfo) || isComposition(propertyInfo);
}
function isOneToOneRelation({ cardinality }) {
    return cardinality === 'ONE_TO_ONE';
}
function isOneToManyRelation({ cardinality }) {
    return cardinality === 'ONE_TO_MANY';
}
function isManyToOneRelation({ cardinality }) {
    return cardinality === 'MANY_TO_ONE';
}
function isManyToManyRelation({ cardinality }) {
    return cardinality === 'MANY_TO_MANY';
}
function isToOneRelation({ cardinality }) {
    return cardinality === "MANY_TO_ONE" || cardinality === "ONE_TO_ONE";
}
function isToManyRelation({ cardinality }) {
    return cardinality === "ONE_TO_MANY" || cardinality === "MANY_TO_MANY";
}
function isAssociation({ attributeType }) {
    return attributeType === 'ASSOCIATION';
}
function isToOneAssociation(propertyInfo) {
    return isToOneRelation(propertyInfo) && isAssociation(propertyInfo);
}
function isToManyAssociation(propertyInfo) {
    return isToManyRelation(propertyInfo) && isAssociation(propertyInfo);
}
function isOneToOneAssociation(propertyInfo) {
    return isAssociation(propertyInfo) && isOneToOneRelation(propertyInfo);
}
function isOneToManyAssociation(propertyInfo) {
    return isAssociation(propertyInfo) && isOneToManyRelation(propertyInfo);
}
function isManyToOneAssociation(propertyInfo) {
    return isAssociation(propertyInfo) && isManyToOneRelation(propertyInfo);
}
function isManyToManyAssociation(propertyInfo) {
    return isAssociation(propertyInfo) && isManyToManyRelation(propertyInfo);
}
function isComposition({ attributeType }) {
    return attributeType === 'COMPOSITION';
}
function isOneToOneComposition(propertyInfo) {
    return isComposition(propertyInfo) && isOneToOneRelation(propertyInfo);
}
function isOneToManyComposition(propertyInfo) {
    return isComposition(propertyInfo) && isOneToManyRelation(propertyInfo);
}

const DEFAULT_DATE_FORMAT = 'YYYY-MM-DD';
const DEFAULT_TIME_FORMAT = 'HH:mm:ss';
const DEFAULT_DATE_TIME_DATA_TRANSFER_FORMAT = 'YYYY-MM-DD HH:mm:ss.SSS';
const DEFAULT_DATE_TIME_DISPLAY_FORMAT = 'YYYY-MM-DD HH:mm:ss';
const OFFSET_DATE_TIME_DATE_TRANSFER_FORMAT = 'YYYY-MM-DD HH:mm:ss.SSS ZZ';
const OFFSET_DATE_TIME_DISPLAY_FORMAT = 'YYYY-MM-DD HH:mm:ss';
const OFFSET_TIME_DATA_TRANSFER_FORMAT = 'HH:mm:ss ZZ';
const OFFSET_TIME_DISPLAY_FORMAT = 'HH:mm:ss';
const defaultDataTransferFormats = {
    date: DEFAULT_DATE_FORMAT,
    time: DEFAULT_TIME_FORMAT,
    dateTime: DEFAULT_DATE_TIME_DATA_TRANSFER_FORMAT,
    localDate: DEFAULT_DATE_FORMAT,
    localTime: DEFAULT_TIME_FORMAT,
    localDateTime: DEFAULT_DATE_TIME_DATA_TRANSFER_FORMAT,
    offsetDateTime: OFFSET_DATE_TIME_DATE_TRANSFER_FORMAT,
    offsetTime: OFFSET_TIME_DATA_TRANSFER_FORMAT
};
const defaultDisplayFormats = {
    date: DEFAULT_DATE_FORMAT,
    time: DEFAULT_TIME_FORMAT,
    dateTime: DEFAULT_DATE_TIME_DISPLAY_FORMAT,
    localDate: DEFAULT_DATE_FORMAT,
    localTime: DEFAULT_TIME_FORMAT,
    localDateTime: DEFAULT_DATE_TIME_DISPLAY_FORMAT,
    offsetDateTime: OFFSET_DATE_TIME_DISPLAY_FORMAT,
    offsetTime: OFFSET_TIME_DISPLAY_FORMAT
};
function getDataTransferFormat(type) {
    var _a, _b;
    return ((_b = (_a = getCubaAppConfig()) === null || _a === void 0 ? void 0 : _a.dataTransferFormats) === null || _b === void 0 ? void 0 : _b[type]) || defaultDataTransferFormats[type];
}
function getDisplayFormat(type) {
    var _a, _b;
    return ((_b = (_a = getCubaAppConfig()) === null || _a === void 0 ? void 0 : _a.displayFormats) === null || _b === void 0 ? void 0 : _b[type]) || defaultDisplayFormats[type];
}

/**
 *
 * @param momentInstance
 *
 * @returns a clone of provided Moment instance with milliseconds set to zero,
 * or `undefined` if a nullish value was provided.
 */
function stripMilliseconds(momentInstance) {
    var _a;
    return (_a = momentInstance) === null || _a === void 0 ? void 0 : _a.clone().milliseconds(0);
}

const TEMPORARY_ENTITY_ID_PREFIX = '_CUBA_TEMPORARY_ENTITY_ID_';
const generateTemporaryEntityId = () => TEMPORARY_ENTITY_ID_PREFIX + Math.random().toString().slice(2);

/**
 *
 * @param entityInstance
 * @param entityName
 * @param metadata
 *
 * @returns a shallow copy of a provided entity instance with temporary ids and read-only properties removed
 * (applied recursively to nested entities)
 */
function prepareForCommit(entityInstance, entityName, metadata) {
    const processedInstance = Object.assign({}, entityInstance);
    Object.keys(processedInstance).forEach(key => {
        const propInfo = getPropertyInfo(metadata, entityName, key);
        if (key === 'id' && typeof processedInstance.id === 'string' && processedInstance.id.startsWith(TEMPORARY_ENTITY_ID_PREFIX)) {
            // Remove temporary id
            delete processedInstance.id;
            return;
        }
        // Remove read-only properties
        if (propInfo != null && propInfo.readOnly) {
            delete processedInstance[key];
            return;
        }
        // Call recursively for nested entities
        if (propInfo != null && processedInstance[key] != null) {
            if (isOneToOneComposition(propInfo)) {
                processedInstance[key] = prepareForCommit(processedInstance[key], propInfo.type, metadata);
                return;
            }
            if (isOneToManyComposition(propInfo)) {
                processedInstance[key] = processedInstance[key].map((e) => prepareForCommit(e, propInfo.type, metadata));
                return;
            }
        }
    });
    return processedInstance;
}

var __decorate$4 = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
/**
 * Retrieves an entity instance using Generic REST API.
 *
 * @typeparam T - entity type.
 */
class DataInstanceStore {
    constructor(mainStore, entityName, viewName = rest.PredefinedView.MINIMAL, stringIdName) {
        this.mainStore = mainStore;
        this.entityName = entityName;
        /**
         * @inheritDoc
         */
        this.status = "CLEAN";
        /**
         * @inheritDoc
         */
        this.changedItems = mobx.observable([]);
        /**
         * Retrieves an entity instance using the given id and view by sending a request to the REST API.
         *
         * @param id - id of an entity instance to be retrieved.
         */
        this.load = (id) => {
            this.item = undefined;
            if (!id) {
                return;
            }
            this.status = "LOADING";
            getCubaREST().loadEntity(this.entityName, id, { view: this.viewName })
                .then((loadedEntity) => {
                mobx.runInAction(() => {
                    this.item = loadedEntity;
                    this.status = "DONE";
                });
            })
                .catch(() => {
                mobx.runInAction(() => {
                    this.status = "ERROR";
                    this.lastError = "LOAD_ERROR";
                });
            });
        };
        /**
         * Sends a request to the REST API to persist the changes made to the {@link item}.
         *
         * @param commitMode - see {@link update}
         *
         * @returns a promise that resolves to the update result returned by the REST API.
         */
        this.commit = (commitMode) => {
            if (this.item == null) {
                return Promise.reject();
            }
            this.status = 'LOADING';
            const commitItem = prepareForCommit(this.item, this.entityName, this.mainStore.metadata);
            const fetchOptions = commitMode != null ? { commitMode } : undefined;
            return getCubaREST().commitEntity(this.entityName, commitItem, fetchOptions)
                .then((updateResult) => {
                mobx.runInAction(() => {
                    if (updateResult.id != null && this.item != null) {
                        this.item.id = updateResult.id;
                        this.item._instanceName = updateResult._instanceName;
                    }
                    this.status = 'DONE';
                });
                return updateResult;
            })
                .catch((e) => {
                this.status = 'ERROR';
                this.lastError = 'COMMIT_ERROR';
                throw e;
            });
        };
        this.viewName = viewName;
        this.stringIdName = stringIdName;
        mobx.reaction(() => this.status, status => this.lastError = status !== "ERROR" ? undefined : this.lastError);
    }
    /**
     * Sets the {@link item} to the provided value. Changes {@link status} to `DONE`.
     *
     * @param item - entity instance to be set as the {@link item}.
     */
    setItem(item) {
        this.item = item;
        this.status = "DONE";
    }
    /**
     * Sets the {@link item} based on provided values of Ant Design {@link https://3x.ant.design/components/form/ | Form} fields.
     *
     * @param formFields - a object representing the values of Ant Design {@link https://3x.ant.design/components/form/ | Form} fields.
     */
    setItemToFormFields(formFields) {
        this.item = formFieldsToInstanceItem(formFields, this.entityName, mobx.toJS(this.mainStore.metadata), this.stringIdName);
        this.status = "DONE";
    }
    // TODO should return Promise<Partial<T>>
    // TODO We might want to make commitMode mandatory in a future major version
    /**
     * Updates the {@link item} using a provided `entityPatch`, then sends a request to the REST API to persist the changes.
     *
     * @param entityPatch - a `Partial` representing the changes to be made.
     * @param commitMode - 'create' when creating a new entity or 'edit' when editing an existing one.
     * Different REST API endpoints and HTTP methods will be used depending on whether the entity is new.
     * IMPORTANT:
     * If this parameter is omitted, then the entity will be considered new if it lacks the `id` attribute.
     * This will produce incorrect results for String ID entities.
     * Therefore using this parameter is mandatory for String ID entities.
     *
     * @returns a promise that resolves to the update result returned by the REST API.
     */
    update(entityPatch, commitMode) {
        const normalizedPatch = formFieldsToInstanceItem(entityPatch, this.entityName, mobx.toJS(this.mainStore.metadata), this.stringIdName);
        Object.assign(this.item, normalizedPatch);
        return this.commit(commitMode);
    }
    /**
     * Transforms the {@link item} into the format expected by Ant Design {@link https://3x.ant.design/components/form/ | Form} fields.
     *
     * @param properties - entity properties that should be included in the result.
     * @returns entity instance transformed into the format expected by Ant Design {@link https://3x.ant.design/components/form/ | Form} fields.
     */
    getFieldValues(properties) {
        return instanceItemToFormFields(this.item || {}, this.entityName, mobx.toJS(this.mainStore.metadata), properties, this.stringIdName);
    }
}
__decorate$4([
    mobx.observable
], DataInstanceStore.prototype, "item", void 0);
__decorate$4([
    mobx.observable
], DataInstanceStore.prototype, "status", void 0);
__decorate$4([
    mobx.observable
], DataInstanceStore.prototype, "lastError", void 0);
__decorate$4([
    mobx.observable
], DataInstanceStore.prototype, "viewName", void 0);
__decorate$4([
    mobx.observable
], DataInstanceStore.prototype, "stringIdName", void 0);
__decorate$4([
    mobx.action
], DataInstanceStore.prototype, "load", void 0);
__decorate$4([
    mobx.action
], DataInstanceStore.prototype, "setItem", null);
__decorate$4([
    mobx.action
], DataInstanceStore.prototype, "setItemToFormFields", null);
__decorate$4([
    mobx.action
], DataInstanceStore.prototype, "update", null);
__decorate$4([
    mobx.action
], DataInstanceStore.prototype, "commit", void 0);
/**
 * Initialization function that instantiates a {@link DataInstanceStore}.
 *
 * @typeparam T - entity type.
 *
 * @param entityName - name of the entity to be retrieved.
 * @param opts - {@link DataInstanceStore} configuration.
 */
function instance(entityName, opts) {
    return new DataInstanceStore(getMainStore(), entityName, opts.view, opts.stringIdName);
}
const withDataInstance = (entityName, opts = { loadImmediately: true }) => (target) => {
    return mobxReact.inject(() => {
        const dataInstance = new DataInstanceStore(getMainStore(), entityName, opts.view, opts.stringIdName);
        return { dataInstance };
    })(target);
};
exports.Instance = class Instance extends React.Component {
    constructor(props) {
        super(props);
        const { entityName, view, stringIdName } = this.props;
        this.store = new DataInstanceStore(getMainStore(), entityName);
        if (view != null) {
            this.store.viewName = view;
        }
        if (stringIdName != null) {
            this.store.stringIdName = stringIdName;
        }
    }
    render() {
        return this.props.children(this.childrenProps);
    }
    get childrenProps() {
        const { item, status, load, commit } = this.store;
        return Object.assign({ item, status, load, commit });
    }
};
__decorate$4([
    mobx.observable
], exports.Instance.prototype, "store", void 0);
__decorate$4([
    mobx.computed
], exports.Instance.prototype, "childrenProps", null);
exports.Instance = __decorate$4([
    mobxReact.observer
], exports.Instance);
// TODO Remove in the next major version
/**
 * @deprecated To be removed from public API
 *
 * @param item
 */
function stripTemporaryIds(item) {
    if (item != null && typeof item === 'object') {
        if ('id' in item && typeof item.id === 'string' && item.id.startsWith(TEMPORARY_ENTITY_ID_PREFIX)) {
            // Remove temporary id
            delete item.id;
        }
        // Repeat for nested entities
        Object.keys(item).forEach(key => {
            stripTemporaryIds(item[key]);
        });
    }
    return item;
}
/**
 * Transforms the antd Form fields values into format expected by Instance item, which is generally the same as the format
 * expected by REST API, except that Instance item may have the following properties that are stripped before the commit:
 * - a temporary id created client-side
 * - read-only attributes
 *
 * @param formFields
 * @param entityName
 * @param metadata
 * @param stringIdName See {@link DataInstanceStore.stringIdName}
 */
function formFieldsToInstanceItem(formFields, entityName, metadata, stringIdName) {
    const item = Object.assign({}, formFields);
    Object.entries(formFields).forEach(([key, value]) => {
        var _a, _b;
        const propInfo = getPropertyInfo(metadata, entityName, key);
        if (key === stringIdName && stringIdName !== 'id') {
            item.id = value;
            delete item[stringIdName];
            return;
        }
        if (propInfo && isOneToOneComposition(propInfo) && value != null) {
            item[key] = formFieldsToInstanceItem(value, propInfo.type, metadata);
            return;
        }
        if (propInfo && isOneToManyComposition(propInfo)) {
            value == null
                ? item[key] = []
                : item[key] = value.map((e) => formFieldsToInstanceItem(e, propInfo.type, metadata));
            return;
        }
        if (propInfo && isToOneAssociation(propInfo) && typeof value === 'string') {
            item[key] = { id: value };
            return;
        }
        if (propInfo && isToManyAssociation(propInfo) && Array.isArray(value)) {
            item[key] = (_a = value) === null || _a === void 0 ? void 0 : _a.map(id => ({ id }));
            return;
        }
        if (propInfo && isTemporalProperty(propInfo) && moment.isMoment(value)) {
            const normalizedValue = stripMilliseconds(value);
            item[key] = (_b = normalizedValue) === null || _b === void 0 ? void 0 : _b.format(getDataTransferFormat(propInfo.type));
            return;
        }
        if (value === '' || value == null) {
            item[key] = null;
            return;
        }
    });
    return item;
}
/**
 * Transforms the provided `item` into the format expected by Ant Design {@link https://3x.ant.design/components/form/ | Form} fields.
 *
 * @typeparam T - entity type.
 *
 * @param item - entity instance to be transformed.
 * @param entityName
 * @param metadata - entities metadata.
 * @param displayedProperties - entity properties that should be included in the result. If not provided, all properties will be included.
 * @param stringIdName See {@link DataInstanceStore.stringIdName}
 */
function instanceItemToFormFields(item, entityName, metadata, displayedProperties, stringIdName) {
    if (item == null || metadata == null) {
        return {};
    }
    const fields = {};
    Object.entries(mobx.toJS(item)).forEach(([key, value]) => {
        const propInfo = getPropertyInfo(metadata, entityName, key);
        const isStringIdAttr = (stringIdName != null) && (key === 'id');
        if (isStringIdAttr) {
            fields[stringIdName] = value;
            return;
        }
        if (displayedProperties != null && displayedProperties.indexOf(key) === -1) {
            return;
        }
        if (propInfo == null) {
            fields[key] = value;
            return;
        }
        if (isOneToOneComposition(propInfo)) {
            if (value != null) {
                fields[key] = instanceItemToFormFields(value, propInfo.type, metadata);
            }
            return;
        }
        if (isOneToManyComposition(propInfo)) {
            value == null
                ? fields[key] = []
                : fields[key] = value.map((e) => instanceItemToFormFields(e, propInfo.type, metadata));
            return;
        }
        if (isToManyAssociation(propInfo)) {
            if (value == null) {
                fields[key] = [];
                return;
            }
            const entityList = value;
            fields[key] = entityList.reduce((accumulator, nextEntity) => {
                accumulator.push(nextEntity.id);
                return accumulator;
            }, []);
            return;
        }
        if (isRelationProperty(propInfo) && value == null) {
            fields[key] = value;
            return;
        }
        if (isFileProperty(propInfo)) {
            fields[key] = {
                id: value.id,
                name: value.name,
            };
            return;
        }
        if (isToOneAssociation(propInfo)) {
            fields[key] = value.id;
            return;
        }
        if (isTemporalProperty(propInfo)) {
            if (value != null) {
                fields[key] = moment(value, getDataTransferFormat(propInfo.type));
            }
            else {
                fields[key] = null;
            }
            return;
        }
        if (value == null) {
            fields[key] = null;
            return;
        }
        fields[key] = value;
        return;
    });
    return fields;
}

/**
 * Invokes Generic REST API to retrieve the possible options for an Association attribute
 * (i.e. entity instances that can be used as a value of that attribute).
 * The request will be sent only if the user has a permission to read that attribute.
 * Returns a `DataCollectionStore` instance (see CUBA React Core API Reference)
 * or `undefined` if the user doesn't have a permission to read the attribute.
 * The instance is returned immediately, but it will only contain the retrieved options
 * once the request to Generic REST API is complete.
 * The instance will contain the retrieved options as its `items` property (MobX observable).
 *
 * @param parentEntityName - name of the entity containing an Association attribute
 * @param attributeName - name of the Association attribute
 * @param nestedEntityName - name of the entity contained in the Association attribute
 * @param getAttributePermission - function returning user's permission for a given entity attribute
 * @param opts - `DataCollectionStore` configuration options
 *
 * @returns a `DataCollectionStore` instance that will (once the request to Generic REST API is complete)
 * contain the retrieved options as its `items` property (MobX observable).
 * If the user doesn't have a permission to read the attribute, an `undefined` will be returned instead.
 */
const loadAssociationOptions = (parentEntityName, attributeName, nestedEntityName, getAttributePermission, opts = { view: "_minimal" }) => {
    const permission = getAttributePermission(parentEntityName, attributeName);
    // `collection` initialization function performs an HTTP request asynchronously
    return (permission === 'VIEW' || permission === 'MODIFY')
        ? collection(nestedEntityName, opts)
        : undefined;
};
/**
 * Invokes Generic REST API to retrieve the lists of possible options for each Association attribute of a given entity
 * (possible options meaning entity instances that can be used as a value of that attribute).
 * Requests will be sent only for the attributes that the user is permitted to read.
 * Returns a `Map` where keys are associated entity names and values are `DataCollectionStore` instances (see CUBA React Core API Reference)
 * or `undefined` if the user doesn't have a permission to read the attribute.
 * The map is returned immediately, but each `DataCollectionStore` will only contain the retrieved options
 * once the corresponding request to Generic REST API is complete.
 * Upon successfull request, a `DataCollectionStore` will contain the retrieved options as its `items` property (MobX observable).
 *
 * @param entityProperties - entity properties metadata
 * @param entityName
 * @param getAttributePermission - function returning user's permission for a given entity attribute
 * @param opts - `DataCollectionStore` configuration options
 *
 * @returns a `Map` where keys are associated entity names and values are `DataCollectionStore` instances
 * that will (once the requests to Generic REST API are complete) contain
 * the retrieved options as their `items` property (MobX observable).
 * If the user doesn't have a permission to read some of the attributes, the corresponding values will contain
 * `undefined`.
 */
const loadAllAssociationOptions = (entityProperties, entityName, getAttributePermission, opts) => {
    const associationOptions = new Map();
    entityProperties.forEach(property => {
        if (property.attributeType !== 'ASSOCIATION' || property.cardinality === 'ONE_TO_MANY') {
            return;
        }
        const nestedEntityName = property.type;
        const optionsContainer = loadAssociationOptions(entityName, property.name, nestedEntityName, getAttributePermission, opts);
        associationOptions.set(nestedEntityName, optionsContainer);
    });
    return associationOptions;
};

/**
 * To be used in (supposedly) unreachable code after exhaustive check of `argument`.
 *
 * @remarks
 * Will cause a compile-time error if `argument` was not exhaustively checked.
 * Will cause a runtime error if reached.
 *
 * @param argumentName
 * @param argument
 */
function assertNever(argumentName, argument) {
    throw new Error(`Unexpected ${argumentName}: ${argument}`);
}

exports.CubaAppProvider = CubaAppProvider;
exports.DEFAULT_DATE_FORMAT = DEFAULT_DATE_FORMAT;
exports.DEFAULT_DATE_TIME_DATA_TRANSFER_FORMAT = DEFAULT_DATE_TIME_DATA_TRANSFER_FORMAT;
exports.DEFAULT_DATE_TIME_DISPLAY_FORMAT = DEFAULT_DATE_TIME_DISPLAY_FORMAT;
exports.DEFAULT_TIME_FORMAT = DEFAULT_TIME_FORMAT;
exports.DataInstanceStore = DataInstanceStore;
exports.MainStore = MainStore;
exports.OFFSET_DATE_TIME_DATE_TRANSFER_FORMAT = OFFSET_DATE_TIME_DATE_TRANSFER_FORMAT;
exports.OFFSET_DATE_TIME_DISPLAY_FORMAT = OFFSET_DATE_TIME_DISPLAY_FORMAT;
exports.OFFSET_TIME_DATA_TRANSFER_FORMAT = OFFSET_TIME_DATA_TRANSFER_FORMAT;
exports.OFFSET_TIME_DISPLAY_FORMAT = OFFSET_TIME_DISPLAY_FORMAT;
exports.TEMPORARY_ENTITY_ID_PREFIX = TEMPORARY_ENTITY_ID_PREFIX;
exports.assertNever = assertNever;
exports.clientSideCollection = clientSideCollection;
exports.collection = collection;
exports.data = data;
exports.defaultCompare = defaultCompare;
exports.defaultDataTransferFormats = defaultDataTransferFormats;
exports.defaultDisplayFormats = defaultDisplayFormats;
exports.defaultOpts = defaultOpts;
exports.formFieldsToInstanceItem = formFieldsToInstanceItem;
exports.fromRestModel = fromRestModel;
exports.generateTemporaryEntityId = generateTemporaryEntityId;
exports.getCubaAppConfig = getCubaAppConfig;
exports.getCubaREST = getCubaREST;
exports.getDataTransferFormat = getDataTransferFormat;
exports.getDisplayFormat = getDisplayFormat;
exports.getEnumCaption = getEnumCaption;
exports.getMainStore = getMainStore;
exports.getMenuItems = getMenuItems;
exports.getPropertyCaption = getPropertyCaption;
exports.getPropertyInfo = getPropertyInfo;
exports.getPropertyInfoNN = getPropertyInfoNN;
exports.injectMainStore = injectMainStore;
exports.instance = instance;
exports.instanceItemToFormFields = instanceItemToFormFields;
exports.isAnyDateProperty = isAnyDateProperty;
exports.isAnyDateTimeProperty = isAnyDateTimeProperty;
exports.isAnyTimeProperty = isAnyTimeProperty;
exports.isAssociation = isAssociation;
exports.isByteArray = isByteArray;
exports.isComposition = isComposition;
exports.isDateProperty = isDateProperty;
exports.isDateTimeProperty = isDateTimeProperty;
exports.isFileProperty = isFileProperty;
exports.isLocalDateProperty = isLocalDateProperty;
exports.isLocalDateTimeProperty = isLocalDateTimeProperty;
exports.isLocalTimeProperty = isLocalTimeProperty;
exports.isManyToManyAssociation = isManyToManyAssociation;
exports.isManyToManyRelation = isManyToManyRelation;
exports.isManyToOneAssociation = isManyToOneAssociation;
exports.isManyToOneRelation = isManyToOneRelation;
exports.isOffsetDateTimeProperty = isOffsetDateTimeProperty;
exports.isOffsetTimeProperty = isOffsetTimeProperty;
exports.isOneToManyAssociation = isOneToManyAssociation;
exports.isOneToManyComposition = isOneToManyComposition;
exports.isOneToManyRelation = isOneToManyRelation;
exports.isOneToOneAssociation = isOneToOneAssociation;
exports.isOneToOneComposition = isOneToOneComposition;
exports.isOneToOneRelation = isOneToOneRelation;
exports.isRelationProperty = isRelationProperty;
exports.isTemporalProperty = isTemporalProperty;
exports.isTimeProperty = isTimeProperty;
exports.isToManyAssociation = isToManyAssociation;
exports.isToManyRelation = isToManyRelation;
exports.isToOneAssociation = isToOneAssociation;
exports.isToOneRelation = isToOneRelation;
exports.loadAllAssociationOptions = loadAllAssociationOptions;
exports.loadAssociationOptions = loadAssociationOptions;
exports.sortEntityInstances = sortEntityInstances;
exports.stripMilliseconds = stripMilliseconds;
exports.stripTemporaryIds = stripTemporaryIds;
exports.withDataCollection = withDataCollection;
exports.withDataInstance = withDataInstance;
